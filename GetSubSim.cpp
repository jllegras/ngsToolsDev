
#include <cstdio>
#include <cstdlib>
#include <sys/stat.h>
#include <cstring>
#include <vector>
#include <math.h>

#include <string> //for str operations
using namespace std;

// a general matrix style structure
template <typename T>
struct matrix{
  int x;
  int y;
  T** data;
};

template <typename T>
struct array{
  int x;
  T* data;
};

template <typename T>
T *collapse(std::vector<T> &v){
  T *tmp = new T[v.size()];
  for(int i=0;i<v.size();i++)
    tmp[i] = v[i];
  return tmp;
}

//function to cleanup our generic matrix structure
template <typename T>
void cleanup(matrix<T> &m){//using a reference to avoid copying the data
  for(int i=0;i<m.x;i++)
    delete [] m.data[i];
  delete [] m.data;
}

// get the filesize of a file
size_t fsize(const char* fname){
  struct stat st ;
  stat(fname,&st);
  return st.st_size;
}

// find out if a file exists
int fexists(const char* str) {
  struct stat buffer ;
  return (stat(str, &buffer )==0 );
}

// a nice wrapper for getting files
FILE *getFILE(const char*fname,const char* mode) {
  int writeFile = 0;
  for(size_t i=0;i<strlen(mode);i++)
    if(mode[i]=='w')
      writeFile = 1;
  if(writeFile&&fexists(fname)){//DRAGON
    fprintf(stderr,"\t-> File exists: %s exiting...\n",fname);
    exit(0);
  }
  FILE *fp;
  if(NULL==(fp=fopen(fname,mode))){
    fprintf(stderr,"\t->Error opening FILE handle for file:%s exiting\n",fname);
    exit(0);
  }
  return fp;
}

// read a file into a matrix but only for a specific subsets of positions (0-based notation)
matrix<double> readFile(char *fname, int nInd, int nSites, int nCat) {
  FILE *fp = getFILE(fname,"rb");
  size_t filesize =fsize(fname);
  if((filesize %(sizeof(double)*(nInd*nSites*nCat)) )) {
    fprintf(stderr,"\n\t-> Possible error,binaryfiles might be broken\n");
    exit(-1);
  }
  double **data = new double*[nInd*nSites];
  fseek(fp, sizeof(double)*(0), SEEK_SET);
  for(int i=0; i<(nSites*nInd); i++) {
    double *tmp = new double[nCat];
    fread(tmp,sizeof(double),nCat,fp);
    data[i]= tmp;
  }
  fclose(fp);
  matrix<double> ret;
  ret.x = (nSites*nInd);
  ret.y = nCat;
  ret.data = data;
  return ret;
}

// this program aims at selecting only a subset of individuals and sites from the file .glf.gz generated by ngsSim
// takes the first nsites_new and nind_new out of the original values

int main (int argc, char *argv[]) {

  char *infile=NULL;

  char *outfile;
  char *foufile=NULL;

  int argPos = 1, nind = 0, nsites = 0, increment=0, debug=0, nind_new = 0, nsites_new = 0, verbose=0;

  while (argPos<argc) {
    increment = 0;
    if(strcmp(argv[argPos],"-infile")==0)
      infile = argv[argPos+1];
    else if(strcmp(argv[argPos],"-nind")==0)
      nind = atoi(argv[argPos+1]);
    else if(strcmp(argv[argPos],"-nsites")==0)
      nsites = atoi(argv[argPos+1]);
    else if(strcmp(argv[argPos],"-outfile")==0)
      outfile = argv[argPos+1];
    else if(strcmp(argv[argPos],"-nind_new")==0)
      nind_new = atoi(argv[argPos+1]);
    else if(strcmp(argv[argPos],"-nsites_new")==0)
      nsites_new = atoi(argv[argPos+1]);
    else if(strcmp(argv[argPos],"-verbose")==0)
      debug = atoi(argv[argPos+1]);
    else {
      printf("\tUnknown arguments: %s\n",argv[argPos]);
      return 0;
    }
    argPos = argPos + 2 + increment;
  } 

  //outfile = getFILE(foutest, "wb");

  matrix<double> glf;
  glf = readFile(infile, nind, nsites, 10);
  if(verbose) fprintf(stderr, "Dim input %d , %d; example %f %f\n", glf.x, glf.y, glf.data[0][0], glf.data[1][1]);

  int conta_ind=0; // counter for individuals at each site
  int conta_site=0; // counter for sites

  int len = nind_new*nsites_new; 

  matrix<double> new_glf;
  double **data = new double*[len];
  for (int i=0; i<len; i++) {
    double *tmp = new double[10];
    data[i] = tmp;
  }
  new_glf.data=data;
  new_glf.x=len;
  new_glf.y=10;

  for (int i=0; i<len; i++) {
    for (int j=0; j<10; j++) {
      new_glf.data[i][j]=0.0;
    }
  }

  int index=0;
  int totind=0;
  conta_site=0;

    for (int i=0; i<nsites; i++) {

      conta_site++; conta_ind=0;

        for (int j=0; j<nind; j++) {

          conta_ind++;

	  if (conta_site<=nsites_new & conta_ind<=nind_new) { // ind to take

            for (int k=0; k<10; k++) new_glf.data[index][k]=glf.data[totind][k];
            index++;

          }

          totind++;

        }


      
    }

  if (verbose) fprintf(stderr, "\nDim output %d , %d; example %f %f;", new_glf.x, new_glf.y, new_glf.data[0][0], new_glf.data[1][1]);

  FILE *fp = fopen(outfile,"wb");

  for (int i=0; i<new_glf.x; i++)
    fwrite(new_glf.data[i], sizeof(double), new_glf.y, fp);

  fclose(fp);
  //fclose(infile);
  //fclose(posfile);

} // main


